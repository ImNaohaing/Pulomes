// Generated by CoffeeScript 1.10.0
(function() {
  var Hexahedron, PBDParticle, appStart, axes, camera, global, initScene, initStats, light, loadFunc, loader, mesh, onWindowResize, orbitControls, ref, renderer, scene, stats, stlMaterial,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  global = {
    compressSpeed: 1,
    eps: 1e-6,
    stiffness: 0.25,
    shapeStiff: 0.17,
    shapeStretch: false,
    generateGeometryFromBufferGeometry: function(bufferGeometry) {
      var compareVertex, face, faces, float32Array, geometry, i, j, k, l, len1, ref, v, v1, v2, v3, vertices;
      float32Array = bufferGeometry.attributes.position.array;
      geometry = new THREE.Geometry();
      vertices = geometry.vertices;
      faces = geometry.faces;
      compareVertex = function(a, b) {
        if (Math.abs(a.x - b.x) > global.eps) {
          return false;
        }
        if (Math.abs(a.y - b.y) > global.eps) {
          return false;
        }
        if (Math.abs(a.z - b.z) > global.eps) {
          return false;
        }
        return true;
      };
      for (i = k = 0, ref = float32Array.length; k < ref; i = k += 9) {
        v1 = new THREE.Vector3(float32Array[i], float32Array[i + 1], float32Array[i + 2]);
        v2 = new THREE.Vector3(float32Array[i + 3], float32Array[i + 4], float32Array[i + 5]);
        v3 = new THREE.Vector3(float32Array[i + 6], float32Array[i + 7], float32Array[i + 8]);
        face = {};
        for (j = l = 0, len1 = vertices.length; l < len1; j = ++l) {
          v = vertices[j];
          if (compareVertex(v1, v) === true) {
            face.a = j;
          }
          if (compareVertex(v2, v) === true) {
            face.b = j;
          }
          if (compareVertex(v3, v) === true) {
            face.c = j;
          }
        }
        if (face.a === void 0) {
          vertices.push(v1);
          face.a = vertices.length - 1;
        }
        if (face.b === void 0) {
          vertices.push(v2);
          face.b = vertices.length - 1;
        }
        if (face.c === void 0) {
          vertices.push(v3);
          face.c = vertices.length - 1;
        }
        faces.push(new THREE.Face3(face.a, face.b, face.c));
      }
      return geometry;
    },
    getE: function(matrix3, r, c) {
      return matrix3.elements[r + c * 3];
    },
    setE: function(matrix3, r, c, e) {
      return matrix3.elements[r + c * 3] = e;
    },
    getRow: function(matrix3, r, vector) {
      if (indexOf.call([0, 1, 2], r) >= 0) {
        vector.x = matrix3.elements[r];
        vector.y = matrix3.elements[r + 3];
        return vector.z = matrix3.elements[r + 6];
      }
    },
    getColumn: function(matrix3, c, vector) {
      var c3;
      if (indexOf.call([0, 1, 2], c) >= 0) {
        c3 = c * 3;
        vector.x = matrix3.elements[c3];
        vector.y = matrix3.elements[c3 + 1];
        return vector.z = matrix3.elements[c3 + 2];
      }
    },
    setRow: function(matrix3, r, vector) {
      if (indexOf.call([0, 1, 2], r) >= 0) {
        matrix3.elements[r] = vector.x;
        matrix3.elements[r + 3] = vector.y;
        return matrix3.elements[r + 6] = vector.z;
      }
    },
    setColumn: function(matrix3, c, vector) {
      var c3;
      if (indexOf.call([0, 1, 2], c) >= 0) {
        c3 = c * 3;
        matrix3.elements[c3] = vector.x;
        matrix3.elements[c3 + 1] = vector.y;
        return matrix3.elements[c3 + 2] = vector.z;
      }
    },
    multiplyMatrices: function(a, b, mat) {
      var i, j, k, results, v, w;
      v = new THREE.Vector3();
      w = new THREE.Vector3();
      results = [];
      for (i = k = 0; k < 3; i = ++k) {
        v.set(a.elements[i], a.elements[i + 3], a.elements[i + 6]);
        results.push((function() {
          var l, results1;
          results1 = [];
          for (j = l = 0; l < 9; j = l += 3) {
            w.set(b.elements[j], b.elements[j + 1], b.elements[j + 2]);
            results1.push(mat.elements[i + j] = v.dot(w));
          }
          return results1;
        })());
      }
      return results;
    },
    polarDecompositionStable: function(M, tolerance, R) {
      var Eone, Et, M2, MadjTinf, MadjTone, MadjTt, Minf, Mone, Mt, det, g1, g2, gamma, i, index, j, k, l, len, m, tmpVec1, tmpVec2, tmpVec3;
      Mt = new THREE.Matrix3().copy(M).transpose();
      Mone = global.oneNorm(M);
      Minf = global.infNorm(M);
      MadjTt = new THREE.Matrix3();
      Et = new THREE.Matrix3();
      tmpVec1 = new THREE.Vector3();
      tmpVec2 = new THREE.Vector3();
      tmpVec3 = new THREE.Vector3();
      Eone = Mone * tolerance + 1;
      while (Eone > Mone * tolerance) {
        this.getRow(Mt, 1, tmpVec1);
        this.getRow(Mt, 2, tmpVec2);
        tmpVec1.cross(tmpVec2);
        this.setRow(MadjTt, 0, tmpVec1);
        this.getRow(Mt, 2, tmpVec1);
        this.getRow(Mt, 0, tmpVec2);
        tmpVec1.cross(tmpVec2);
        this.setRow(MadjTt, 1, tmpVec1);
        this.getRow(Mt, 0, tmpVec1);
        this.getRow(Mt, 1, tmpVec2);
        tmpVec1.cross(tmpVec2);
        this.setRow(MadjTt, 2, tmpVec1);
        this.getRow(Mt, 0, tmpVec1);
        this.getRow(MadjTt, 0, tmpVec2);
        det = tmpVec1.dot(tmpVec2);
        if (Math.abs(det) < 1e-12) {
          index = void 0;
          for (i = k = 0; k <= 2; i = ++k) {
            this.getRow(MadjTt, i, tmpVec1);
            len = tmpVec1.lengthSq();
            if (len > 1e-12) {
              index = i;
              break;
            }
          }
          if (index === void 0) {
            R.identity();
            return;
          } else {
            this.getRow(Mt, (index + 1) % 3, tmpVec1);
            this.getRow(Mt, (index + 2) % 3, tmpVec2);
            tmpVec1.cross(tmpVec2);
            this.setRow(Mt, index, tmpVec1);
            this.getRow(Mt, (index + 2) % 3, tmpVec1);
            this.getRow(Mt, index, tmpVec2);
            tmpVec1.cross(tmpVec2);
            this.setRow(Mt, (index + 1) % 3, tmpVec1);
            this.getRow(Mt, index, tmpVec1);
            this.getRow(Mt, (index + 1) % 3, tmpVec2);
            tmpVec1.cross(tmpVec2);
            this.setRow(Mt, (index + 2) % 3, tmpVec1);
            M2 = new THREE.Matrix3();
            M2.copy(Mt).transpose();
            Mone = this.oneNorm(M2);
            Minf = this.infNorm(M2);
            this.getRow(Mt, 0, tmpVec1);
            this.getRow(MadjTt, 0, tmpVec2);
            det = tmpVec1.dot(tmpVec2);
          }
        }
        MadjTone = this.oneNorm(MadjTt);
        MadjTinf = this.infNorm(MadjTt);
        gamma = Math.sqrt(Math.sqrt((MadjTone * MadjTinf) / (Mone * Minf)) / Math.abs(det));
        g1 = gamma * 0.5;
        g2 = 0.5 / (gamma * det);
        for (i = l = 0; l <= 2; i = ++l) {
          for (j = m = 0; m <= 2; j = ++m) {
            this.setE(Et, i, j, this.getE(Mt, i, j));
            this.setE(Mt, i, j, g1 * this.getE(Mt, i, j) + g2 * this.getE(MadjTt, i, j));
            this.setE(Et, i, j, this.getE(Et, i, j) - this.getE(Mt, i, j));
          }
        }
        Eone = this.oneNorm(Et);
        Mone = this.oneNorm(Mt);
        Minf = this.infNorm(Mt);
      }
      return R.copy(Mt).transpose();
    },
    oneNorm: function(matrix3) {
      var e, i, k, ref, sums;
      e = matrix3.elements;
      sums = [];
      for (i = k = 0, ref = e.length; k < ref; i = k += 3) {
        sums.push(Math.abs(e[i]) + Math.abs(e[i + 1]) + Math.abs(e[i + 2]));
      }
      return Math.max.apply(Math, sums);
    },
    infNorm: function(matrix3) {
      var e, i, k, sums;
      e = matrix3.elements;
      sums = [];
      for (i = k = 0; k <= 2; i = ++k) {
        sums.push(Math.abs(e[i]) + Math.abs(e[i + 3]) + Math.abs(e[i + 6]));
      }
      return Math.max.apply(Math, sums);
    },
    computeVolume: function(vertices, faceIndices) {
      var i, k, norm, p1, p2, p3, pSum, ref, v21, v31, volume;
      v21 = new THREE.Vector3();
      v31 = new THREE.Vector3();
      norm = new THREE.Vector3();
      pSum = new THREE.Vector3(0, 0, 0);
      volume = 0;
      for (i = k = 0, ref = faceIndices.length; k < ref; i = k += 3) {
        p1 = vertices[faceIndices[i]].position;
        p2 = vertices[faceIndices[i + 1]].position;
        p3 = vertices[faceIndices[i + 2]].position;
        pSum.addVectors(p1, p2).add(p3);
        v21.subVectors(p2, p1);
        v31.subVectors(p3, p1);
        norm.crossVectors(v21, v31);
        volume += pSum.dot(norm);
      }
      return volume /= 18;
    },
    computeVolumeTHREE: function(vertices, faces) {
      var i, k, norm, p1, p2, p3, pSum, ref, v21, v31, volume;
      v21 = new THREE.Vector3();
      v31 = new THREE.Vector3();
      norm = new THREE.Vector3();
      pSum = new THREE.Vector3(0, 0, 0);
      volume = 0;
      for (i = k = 0, ref = faces.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        p1 = vertices[faces[i].a];
        p2 = vertices[faces[i].b];
        p3 = vertices[faces[i].c];
        pSum.addVectors(p1, p2).add(p3);
        v21.subVectors(p2, p1);
        v31.subVectors(p3, p1);
        norm.crossVectors(v21, v31);
        volume += pSum.dot(norm);
      }
      volume /= 18;
      return console.log(volume);
    },
    generateTopologyModelTHREE: function(vertices, faces) {
      var face, i, k, len1, vertexTopo;
      vertexTopo = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = vertices.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
          results.push([]);
        }
        return results;
      })();
      for (i = k = 0, len1 = faces.length; k < len1; i = ++k) {
        face = faces[i];
        vertexTopo[face.a].push(i);
        vertexTopo[face.b].push(i);
        vertexTopo[face.c].push(i);
      }
      return vertexTopo;
    },
    computeWeighedNorms: function(topology, vertices, faces) {
      var face, fi, k, l, len1, len2, norm, normSum, p1, p2, p3, v21, v31, vtopo, wnvector;
      v21 = new THREE.Vector3();
      v31 = new THREE.Vector3();
      norm = new THREE.Vector3();
      wnvector = [];
      for (k = 0, len1 = topology.length; k < len1; k++) {
        vtopo = topology[k];
        normSum = new THREE.Vector3(0, 0, 0);
        for (l = 0, len2 = vtopo.length; l < len2; l++) {
          fi = vtopo[l];
          face = faces[fi];
          p1 = vertices[face.a];
          p2 = vertices[face.b];
          p3 = vertices[face.c];
          v21.subVectors(p2, p1);
          v31.subVectors(p3, p1);
          norm.crossVectors(v21, v31);
          normSum.add(norm);
        }
        normSum.multiplyScalar(0.5);
        wnvector.push(normSum);
      }
      return wnvector;
    },
    computeVolumeByWeighedNorms: function(weightedNorms, vertices) {
      var i, k, len1, v, volume;
      volume = 0;
      for (i = k = 0, len1 = vertices.length; k < len1; i = ++k) {
        v = vertices[i];
        volume += v.dot(weightedNorms[i]);
      }
      return volume /= 9;
    },
    computeVolumeConstrain: function(restVolume, topology, vertices, faces, options) {
      var coff, correct, corrects, curVolume, diff, k, l, len1, len2, localWeights, normSq, w, wNorms;
      localWeights = options != null ? options.localWeights.localWeights : void 0;
      wNorms = global.computeWeighedNorms(topology, vertices, faces);
      curVolume = global.computeVolumeByWeighedNorms(wNorms, vertices);
      diff = curVolume - restVolume;
      normSq = 0;
      for (k = 0, len1 = wNorms.length; k < len1; k++) {
        w = wNorms[k];
        normSq += w.lengthSq();
      }
      coff = Math.abs(normSq) > global.eps ? diff * 3 / normSq : 0;
      if (normSq === 0) {
        console.warn("scope " + this + ": normSq appear 0, please check function \"computeVolumeConstrain\"");
      }
      corrects = [];
      for (l = 0, len2 = wNorms.length; l < len2; l++) {
        w = wNorms[l];
        correct = new THREE.Vector3().copy(w);
        correct.multiplyScalar(-coff);
        corrects.push(correct);
      }
      return corrects;
    },
    initShapeMatching: function(x0, restCm, invRestMat) {
      var A, det, k, l, len1, len2, qi, ret, v, x2, xy, xz, y2, yz, z2;
      restCm.set(0, 0, 0);
      A = new THREE.Matrix3();
      A.set.apply(A, [0, 0, 0, 0, 0, 0, 0, 0, 0]);
      invRestMat.set.apply(invRestMat, [0, 0, 0, 0, 0, 0, 0, 0, 0]);
      for (k = 0, len1 = x0.length; k < len1; k++) {
        v = x0[k];
        restCm.add(v);
      }
      restCm.multiplyScalar(1 / x0.length);
      qi = new THREE.Vector3(0, 0, 0);
      for (l = 0, len2 = x0.length; l < len2; l++) {
        v = x0[l];
        qi.subVectors(v, restCm);
        x2 = qi.x * qi.x;
        y2 = qi.y * qi.y;
        z2 = qi.z * qi.z;
        xy = qi.x * qi.y;
        xz = qi.x * qi.z;
        yz = qi.y * qi.z;
        A.elements[0] += x2;
        A.elements[3] += xy;
        A.elements[6] += xz;
        A.elements[1] += xy;
        A.elements[4] += y2;
        A.elements[7] += yz;
        A.elements[2] += xz;
        A.elements[5] += yz;
        A.elements[8] += z2;
      }
      det = A.determinant();
      ret = false;
      if (Math.abs(det) > global.eps) {
        invRestMat.getInverse(A, ret);
      }
      return ret;
    },
    computeShapeMatching: function(x0, x, restCm, invRestMat, stiff, allowStrech) {
      var corr, curCm, goal, i, k, l, len1, m, mat, p, q, ref, ref1, result, v;
      curCm = new THREE.Vector3(0, 0, 0);
      for (k = 0, len1 = x.length; k < len1; k++) {
        v = x[k];
        curCm.add(v);
      }
      curCm.multiplyScalar(1 / x.length);
      mat = new THREE.Matrix3();
      mat.set.apply(mat, [0, 0, 0, 0, 0, 0, 0, 0, 0]);
      q = new THREE.Vector3(0, 0, 0);
      p = new THREE.Vector3(0, 0, 0);
      for (i = l = 0, ref = x.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        q.subVectors(x0[i], restCm);
        p.subVectors(x[i], curCm);
        mat.elements[0] += p.x * q.x;
        mat.elements[3] += p.x * q.y;
        mat.elements[6] += p.x * q.z;
        mat.elements[1] += p.y * q.x;
        mat.elements[4] += p.y * q.y;
        mat.elements[7] += p.y * q.z;
        mat.elements[2] += p.z * q.x;
        mat.elements[5] += p.z * q.y;
        mat.elements[8] += p.z * q.z;
      }
      result = new THREE.Matrix3();
      global.multiplyMatrices(mat, invRestMat, result);
      mat.copy(result);
      if (allowStrech === false) {
        global.polarDecompositionStable(mat, global.eps, result);
      }
      corr = [];
      for (i = m = 0, ref1 = x0.length; 0 <= ref1 ? m < ref1 : m > ref1; i = 0 <= ref1 ? ++m : --m) {
        goal = new THREE.Vector3().subVectors(x0[i], restCm).applyMatrix3(result).add(curCm);
        goal.sub(x[i]).multiplyScalar(stiff);
        corr.push(goal);
      }
      return corr;
    },
    applyConstrains: function(p2, p1, distance, iterTimes) {
      var correction, currectionHalf, currentDist, diff;
      if (iterTimes == null) {
        iterTimes = 0;
      }
      diff = new THREE.Vector3().subVectors(p2, p1);
      currentDist = diff.length();
      if (currentDist === 0) {
        return;
      }
      correction = diff.multiplyScalar(1 - distance / currentDist);
      currectionHalf = correction.multiplyScalar(0.5).multiplyScalar(1 - Math.pow(1 - this.stiffness, 1 / (iterTimes + 1)));
      p1.add(currectionHalf);
      return p2.sub(currectionHalf);
    }
  };

  PBDParticle = (function() {
    function PBDParticle(x, y, z, mass) {
      this.previous = new THREE.Vector3(x, y, z);
      this.position = new THREE.Vector3(x, y, z);
      this.original = new THREE.Vector3(x, y, z);
      this.velocity = new THREE.Vector3(0, 0, 0);
      this.tmp = new THREE.Vector3();
      this.tmp2 = new THREE.Vector3();
      this.mass = mass;
      this.invmass = this.mass === 0 ? 0 : 1 / this.mass;
      this.a = new THREE.Vector3(0, 0, 0);
    }

    PBDParticle.prototype.addForce = function(force) {
      this.tmp.copy(force).multiplyScalar(this.invmass);
      return this.a.add(this.tmp);
    };

    PBDParticle.prototype.integrate = function(deltaTime, drag) {
      var diff;
      diff = this.tmp2;
      this.velocity.add(this.a.multiplyScalar(deltaTime));
      diff.copy(this.velocity).multiplyScalar(drag * deltaTime).add(this.position);
      this.tmp2 = this.previous;
      this.previous = this.position;
      this.position = diff;
      return this.a.set(0, 0, 0);
    };

    return PBDParticle;

  })();

  Hexahedron = (function() {
    function Hexahedron(vertices, mass) {
      var k, len1, pos, v;
      this.particleMass = mass / 8;
      this.particleInvmass = this.particleMass === 0 ? 0 : 1 / this.particleMass;
      this.particles = [];
      for (k = 0, len1 = vertices.length; k < len1; k++) {
        v = vertices[k];
        pos = v.position;
        this.particles.push(new PBDParticle(pos.x, pos.y, pos.z, this.particleMass));
      }
    }

    Hexahedron.prototype.addVolumeConstrain = function() {};

    return Hexahedron;

  })();

  onWindowResize = function() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    return renderer.setSize(window.innerWidth, window.innerHeight);
  };

  window.addEventListener('resize', onWindowResize, false);

  initStats = function() {
    var stats;
    stats = new Stats();
    stats.setMode(0);
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    return stats;
  };

  initScene = function() {
    var camera, orbitControls, renderer, scene;
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.x = -30;
    camera.position.y = 40;
    camera.position.z = 30;
    camera.lookAt(scene.position);
    renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0xEEEEEE);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    orbitControls = new THREE.OrbitControls(camera);
    orbitControls.autoRotate = false;
    return {
      scene: scene,
      camera: camera,
      renderer: renderer,
      orbitControls: orbitControls
    };
  };

  stats = initStats();

  document.getElementById("stats-output").appendChild(stats.domElement);

  ref = initScene(), scene = ref.scene, camera = ref.camera, renderer = ref.renderer, orbitControls = ref.orbitControls;

  document.body.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0x666666, 1.8));

  light = new THREE.DirectionalLight(0xdfebff, 1.0);

  light.position.set(50, 200, 100);

  light.castShadow = true;

  light.shadow.camera.near = 2;

  light.shadow.camera.far = 1000;

  light.shadow.camera.left = -500;

  light.shadow.camera.right = 500;

  light.shadow.camera.top = 500;

  light.shadow.camera.bottom = -500;

  light.shadow.mapSize.width = 1024;

  light.shadow.mapSize.height = 1024;

  scene.add(light);

  axes = new THREE.AxisHelper(20);

  scene.add(axes);

  mesh = void 0;

  loader = new THREE.STLLoader();

  stlMaterial = new THREE.MeshNormalMaterial({
    color: 0xAAAAAA,
    specular: 0x111111,
    shininess: 200
  });

  loadFunc = function(bufferGeometry) {
    var geometry, k, len1, ref1, v;
    geometry = global.generateGeometryFromBufferGeometry(bufferGeometry);
    mesh = new THREE.Mesh(geometry, stlMaterial);
    mesh.position.set(0, 0, -10);
    mesh.rotation.set(0, 0, -Math.PI / 2.8);
    mesh.scale.set(0.3, 0.3, 0.3);
    mesh.updateMatrixWorld();
    ref1 = geometry.vertices;
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      v = ref1[k];
      v.applyMatrix4(mesh.matrixWorld);
    }
    mesh.rotation.set(0, 0, 0);
    mesh.scale.set(1, 1, 1);
    mesh.position.set(0, 0, 0);
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();
    scene.add(mesh);
    bufferGeometry.dispose();
    return appStart();
  };

  loader.load("../models/马里奥.stl", loadFunc);

  appStart = function() {
    var clock, distanceConstrains, f, fa, fb, fc, geometry, geometryTopo, gui, h, invRestMat, k, l, len1, len2, planeGeo, planeLeft, planeMat, planeMatTop, planeObj, planeRight, planeSideGeo, ref1, ref2, render, restCm, restVolume, tmpVec, trans, updateDistanceConstrains, updatePlaneConstrains, v, wnv, x0;
    geometry = mesh.geometry;
    x0 = [];
    ref1 = geometry.vertices;
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      v = ref1[k];
      x0.push(new THREE.Vector3().copy(v));
    }
    restCm = new THREE.Vector3();
    invRestMat = new THREE.Matrix3();
    global.initShapeMatching(geometry.vertices, restCm, invRestMat);
    console.log("x:" + restCm.x + " , y:" + restCm.y + " , z:" + restCm.z);
    console.log(global.computeVolumeTHREE(geometry.vertices, geometry.faces));
    geometryTopo = global.generateTopologyModelTHREE(geometry.vertices, geometry.faces);
    wnv = global.computeWeighedNorms(geometryTopo, geometry.vertices, geometry.faces);
    restVolume = global.computeVolumeByWeighedNorms(wnv, geometry.vertices);
    console.log(restVolume);
    planeGeo = new THREE.PlaneGeometry(36, 36);
    planeMatTop = new THREE.MeshBasicMaterial({
      color: 0x22b5ff,
      side: THREE.DoubleSide
    });
    planeMat = new THREE.MeshBasicMaterial({
      color: 0x22b5ff,
      side: THREE.DoubleSide
    });
    planeMatTop.transparent = true;
    planeMat.transparent = true;
    planeMatTop.opacity = 0.1;
    planeMat.opacity = 0.1;
    planeObj = new THREE.Mesh(planeGeo, planeMatTop);
    planeSideGeo = new THREE.PlaneGeometry(50, 20);
    planeLeft = new THREE.Mesh(planeSideGeo, planeMat);
    planeRight = new THREE.Mesh(planeSideGeo, planeMat);
    planeObj.rotation.x = Math.PI / 2;
    planeLeft.rotation.y = Math.PI / 2;
    planeRight.rotation.y = Math.PI / 2;
    planeObj.position.set(0, 15, 10);
    planeLeft.position.set(-15, 0, 0);
    planeRight.position.set(+7, 0, 0);
    scene.add(planeObj);
    scene.add(planeLeft);
    scene.add(planeRight);
    trans = new THREE.Vector3(0, 0, 0);
    gui = new dat.GUI();
    h = gui.addFolder("Plane Y Postion");
    h.add(planeObj.position, "y", 0, 13);
    h.open();
    h = gui.addFolder("Coeffience");
    h.add(global, "stiffness", 0, 1);
    h.add(global, "shapeStiff", 0, 1);
    h.add(global, "shapeStretch").onChange();
    updatePlaneConstrains = function() {
      var correctX, correctY, l, len2, ref2, results, tmpVec;
      tmpVec = new THREE.Vector3();
      ref2 = geometry.vertices;
      results = [];
      for (l = 0, len2 = ref2.length; l < len2; l++) {
        v = ref2[l];
        correctY = THREE.Math.clamp(v.y, -3, planeObj.position.y);
        v.y = correctY;
        correctX = THREE.Math.clamp(v.x, planeLeft.position.x, planeRight.position.x);
        v.x = correctX;
        if (v.y < -3) {
          results.push(v.y = -3);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    distanceConstrains = [];
    tmpVec = new THREE.Vector3();
    ref2 = geometry.faces;
    for (l = 0, len2 = ref2.length; l < len2; l++) {
      f = ref2[l];
      fa = geometry.vertices[f.a];
      fb = geometry.vertices[f.b];
      fc = geometry.vertices[f.c];
      distanceConstrains.push([fa, fb, tmpVec.subVectors(fa, fb).length()]);
      distanceConstrains.push([fa, fc, tmpVec.subVectors(fa, fc).length()]);
      distanceConstrains.push([fb, fc, tmpVec.subVectors(fb, fc).length()]);
    }
    updateDistanceConstrains = function() {
      var dc, len3, m, results;
      results = [];
      for (m = 0, len3 = distanceConstrains.length; m < len3; m++) {
        dc = distanceConstrains[m];
        results.push(global.applyConstrains(dc[1], dc[0], dc[2]));
      }
      return results;
    };
    clock = new THREE.Clock();
    render = function() {
      var corrects, corrs, delta, i, len3, len4, m, n, o, ref3, ref4, volume;
      delta = clock.getDelta();
      orbitControls.update(delta);
      planeLeft.position.x = -Math.sin(clock.getElapsedTime()) * 13 - 10;
      updatePlaneConstrains();
      wnv = global.computeWeighedNorms(geometryTopo, geometry.vertices, geometry.faces);
      volume = global.computeVolumeByWeighedNorms(wnv, geometry.vertices);
      corrects = global.computeVolumeConstrain(restVolume, geometryTopo, geometry.vertices, geometry.faces);
      ref3 = geometry.vertices;
      for (i = m = 0, len3 = ref3.length; m < len3; i = ++m) {
        v = ref3[i];
        v.add(corrects[i]);
      }
      for (i = n = 0; n < 2; i = ++n) {
        corrs = global.computeShapeMatching(x0, geometry.vertices, restCm, invRestMat, global.shapeStiff, global.shapeStretch);
        ref4 = geometry.vertices;
        for (i = o = 0, len4 = ref4.length; o < len4; i = ++o) {
          v = ref4[i];
          v.add(corrs[i]);
        }
      }
      updateDistanceConstrains();
      geometry.computeFaceNormals();
      geometry.computeVertexNormals();
      geometry.normalsNeedUpdate = true;
      geometry.verticesNeedUpdate = true;
      stats.update();
      requestAnimationFrame(render);
      return renderer.render(scene, camera);
    };
    return render();
  };

}).call(this);

//# sourceMappingURL=PBDVolume.js.map
