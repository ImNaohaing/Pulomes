// Generated by CoffeeScript 1.10.0
(function() {
  var Cloth, ClothParticle, TIMESTEP, TIMESTEP_SQ, axes, camera, cloth, clothFrameMaterial, clothGeo, clothMaterial, clothObj, global, gravity, gui, h, initScene, initStats, light, onWindowResize, pins, ref, render, renderer, scene, stats, wind;

  gravity = new THREE.Vector3(0, -9.8, 0);

  TIMESTEP = 18 / 1000;

  TIMESTEP_SQ = TIMESTEP * TIMESTEP;

  pins = [0, 20];

  wind = new THREE.Vector3(0, 5, 15);

  global = {
    wireframe: true
  };

  Cloth = (function() {
    Cloth.prototype.damping = 0.03;

    Cloth.prototype.drag = 1 - 0.03;

    Cloth.prototype.mass = 0.1;

    Cloth.prototype.w = 0;

    Cloth.prototype.h = 0;

    Cloth.prototype.particles = void 0;

    Cloth.prototype.constrains = void 0;

    Cloth.prototype.clothFunc = void 0;

    Cloth.prototype.diff = void 0;

    function Cloth(restDist, xSegs, ySegs, material) {
      var j, k, l, m, n, o, ref, ref1, ref2, ref3, ref4, ref5, u, v;
      xSegs = xSegs || 10;
      ySegs = ySegs || 10;
      this.w = xSegs;
      this.h = ySegs;
      this.particles = [];
      this.constrains = [];
      this.diff = new THREE.Vector3();
      this.clothFunc = this.plane(restDist * xSegs, restDist * ySegs);
      for (v = j = 0, ref = ySegs; 0 <= ref ? j <= ref : j >= ref; v = 0 <= ref ? ++j : --j) {
        for (u = k = 0, ref1 = xSegs; 0 <= ref1 ? k <= ref1 : k >= ref1; u = 0 <= ref1 ? ++k : --k) {
          this.particles.push(new ClothParticle(this.clothFunc(u / xSegs, v / ySegs), this.mass));
        }
      }
      for (v = l = 0, ref2 = ySegs - 1; 0 <= ref2 ? l <= ref2 : l >= ref2; v = 0 <= ref2 ? ++l : --l) {
        for (u = m = 0, ref3 = xSegs - 1; 0 <= ref3 ? m <= ref3 : m >= ref3; u = 0 <= ref3 ? ++m : --m) {
          this.constrains.push([this.particles[this.index(u, v)], this.particles[this.index(u, v + 1)], restDist]);
          this.constrains.push([this.particles[this.index(u, v)], this.particles[this.index(u + 1, v)], restDist]);
        }
      }
      u = xSegs;
      for (v = n = 0, ref4 = ySegs - 1; 0 <= ref4 ? n <= ref4 : n >= ref4; v = 0 <= ref4 ? ++n : --n) {
        this.constrains.push([this.particles[this.index(u, v)], this.particles[this.index(u, v + 1)], restDist]);
      }
      v = ySegs;
      for (u = o = 0, ref5 = xSegs - 1; 0 <= ref5 ? o <= ref5 : o >= ref5; u = 0 <= ref5 ? ++o : --o) {
        this.constrains.push([this.particles[this.index(u, v)], this.particles[this.index(u + 1, v)], restDist]);
      }
    }

    Cloth.prototype.index = function(u, v) {
      return u + v * (this.w + 1);
    };

    Cloth.prototype.plane = function(w, h) {
      return function(u, v) {
        var x, y, z;
        x = (u - 0.5) * w;
        y = (v + 0.5) * h;
        z = 0;
        return new THREE.Vector3(x, y, z);
      };
    };

    Cloth.prototype.simulate = function(time, clothFaces, windForce) {
      var constrain, constrains, face, gForce, i, j, k, l, lastTime, len, len1, m, normal, particle, particles, ref, results, tmpForce, xy;
      if (typeof lastTime !== "undefined" && lastTime !== null) {
        lastTime = time;
        return;
      }
      particles = this.particles;
      tmpForce = new THREE.Vector3();
      if (wind != null) {
        for (j = 0, len = clothFaces.length; j < len; j++) {
          face = clothFaces[j];
          normal = face.normal;
          tmpForce.copy(normal).normalize().multiplyScalar(normal.dot(windForce));
          particles[face.a].addForce(tmpForce);
          particles[face.b].addForce(tmpForce);
          particles[face.c].addForce(tmpForce);
        }
      }
      gForce = new THREE.Vector3();
      for (k = 0, len1 = particles.length; k < len1; k++) {
        particle = particles[k];
        gForce.copy(gravity).multiplyScalar(this.mass);
        particle.addForce(gForce);
        particle.integrate(TIMESTEP_SQ, this.drag);
      }
      results = [];
      for (i = l = 0; l < 1; i = ++l) {
        constrains = this.constrains;
        for (i = m = 0, ref = constrains.length - 1; 0 <= ref ? m <= ref : m >= ref; i = 0 <= ref ? ++m : --m) {
          constrain = constrains[i];
          this.satisfyConstrains(constrain[0], constrain[1], constrain[2]);
        }
        results.push((function() {
          var n, ref1, results1;
          results1 = [];
          for (i = n = 0, ref1 = pins.length - 1; 0 <= ref1 ? n <= ref1 : n >= ref1; i = 0 <= ref1 ? ++n : --n) {
            xy = pins[i];
            particle = particles[xy];
            particle.position.copy(particle.original);
            results1.push(particle.previous.copy(particle.original));
          }
          return results1;
        })());
      }
      return results;
    };

    Cloth.prototype.satisfyConstrains = function(p1, p2, distance) {
      var correction, currectionHalf, currentDist;
      this.diff.subVectors(p2.position, p1.position);
      currentDist = this.diff.length();
      if (currentDist === 0) {
        return;
      }
      correction = this.diff.multiplyScalar(1 - distance / currentDist);
      currectionHalf = correction.multiplyScalar(0.5);
      p1.position.add(currectionHalf);
      return p2.position.sub(currectionHalf);
    };

    return Cloth;

  })();

  ClothParticle = (function() {
    ClothParticle.prototype.position = void 0;

    ClothParticle.prototype.previous = void 0;

    ClothParticle.prototype.original = void 0;

    ClothParticle.prototype.a = void 0;

    ClothParticle.prototype.mass = 0;

    ClothParticle.prototype.invmass = 0;

    ClothParticle.prototype.tmp = void 0;

    ClothParticle.prototype.tmp2 = void 0;

    function ClothParticle(position, mass) {
      this.position = new THREE.Vector3().copy(position);
      this.previous = new THREE.Vector3().copy(position);
      this.original = new THREE.Vector3().copy(position);
      this.a = new THREE.Vector3(0, 0, 0);
      this.mass = mass;
      this.invmass = mass === 0 ? mass : 1 / mass;
      this.tmp = new THREE.Vector3();
      this.tmp2 = new THREE.Vector3();
    }

    ClothParticle.prototype.addForce = function(force) {
      this.tmp2.copy(force).multiplyScalar(this.invmass);
      return this.a.add(this.tmp2);
    };

    ClothParticle.prototype.integrate = function(timesq, drag) {
      var newPos;
      newPos = this.tmp.subVectors(this.position, this.previous);
      newPos.multiplyScalar(drag).add(this.position);
      newPos.add(this.a.multiplyScalar(timesq));
      this.tmp = this.previous;
      this.previous = this.position;
      this.position = newPos;
      return this.a.set(0, 0, 0);
    };

    return ClothParticle;

  })();

  onWindowResize = function() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    return renderer.setSize(window.innerWidth, window.innerHeight);
  };

  window.addEventListener('resize', onWindowResize, false);

  initStats = function() {
    var stats;
    stats = new Stats();
    stats.setMode(0);
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    return stats;
  };

  initScene = function() {
    var camera, renderer, scene;
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.x = -300;
    camera.position.y = 400;
    camera.position.z = 300;
    camera.lookAt(scene.position);
    renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(0xEEEEEE);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = false;
    return {
      scene: scene,
      camera: camera,
      renderer: renderer
    };
  };

  gui = new dat.GUI();

  gui.add(global, "wireframe").onChange();

  h = gui.addFolder("Wind Force");

  h.add(wind, "x", -10, 20);

  h.add(wind, "y", -10, 20);

  h.add(wind, "z", -10, 20);

  stats = initStats();

  document.getElementById("stats-output").appendChild(stats.domElement);

  ref = initScene(), scene = ref.scene, camera = ref.camera, renderer = ref.renderer;

  document.body.appendChild(renderer.domElement);

  light = new THREE.DirectionalLight(0xdfebff, 1.75);

  light.position.set(50, 200, -100);

  light.castShadow = true;

  light.shadow.camera.near = 2;

  light.shadow.camera.far = 1000;

  light.shadow.camera.left = -500;

  light.shadow.camera.right = 500;

  light.shadow.camera.top = 500;

  light.shadow.camera.bottom = -500;

  light.shadow.mapSize.width = 1024;

  light.shadow.mapSize.height = 1024;

  scene.add(light);

  cloth = new Cloth(5, 20, 20);

  clothMaterial = new THREE.MeshLambertMaterial({
    color: 0x22b5ff,
    side: THREE.DoubleSide
  });

  clothFrameMaterial = new THREE.MeshBasicMaterial({
    color: 0xff0000,
    wireframe: true
  });

  clothGeo = new THREE.ParametricGeometry(cloth.clothFunc, cloth.w, cloth.h);

  clothObj = THREE.SceneUtils.createMultiMaterialObject(clothGeo, [clothMaterial, clothFrameMaterial]);

  clothObj.position.set(0, 0, 0);

  clothObj.children[0].castShadow = true;

  scene.add(clothObj);

  axes = new THREE.AxisHelper(20);

  scene.add(axes);

  render = function() {
    var i, j, p, ref1, time;
    time = Date.now();
    cloth.simulate(time, clothGeo.faces, wind);
    clothFrameMaterial.wireframe = global.wireframe;
    p = cloth.particles;
    for (i = j = 0, ref1 = p.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
      clothGeo.vertices[i].copy(p[i].position);
    }
    clothGeo.computeFaceNormals();
    clothGeo.computeVertexNormals();
    clothGeo.normalsNeedUpdate = true;
    clothGeo.verticesNeedUpdate = true;
    stats.update();
    requestAnimationFrame(render);
    return renderer.render(scene, camera);
  };

  render();

}).call(this);

//# sourceMappingURL=ClothApp.js.map
